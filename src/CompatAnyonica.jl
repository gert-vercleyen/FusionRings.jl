
module CompatAnyonica

# Thin compatibility layer mapping Anyonica-style function names
# to FusionRings.jl (Sami version) implementations.
#
# These wrappers keep labels as Strings and provide friendly errors
# when functionality is not yet available.

using ..Types
using ..Operations
using ..Properties
using ..GroupTheory
using ..Creation

export son2_fusion_ring,
       hi_fusion_ring,
       which_decompositions,
       adjoint_irreps,
       adjoint_fusion_ring,
       is_nilpotent_fusion_ring,
       commutator,
       upper_central_series,
       universal_grading,
       all_gradings,
       fusion_ring_automorphisms,
       identify_fusion_ring,
       group_fusion_ring,
       num_self_dual, nsd,
       num_non_self_dual, nnsd

# direct forwards / aliases where we have equivalents

const NotImpl = ErrorException("Not implemented yet. This name is provided for compatibility; see docs.")

# --- Decomposition helpers ---
which_decompositions(::FusionRing) = throw(NotImpl)

# --- Adjoint objects ---
adjoint_irreps(R::FusionRing) = GroupTheory.adjoint_irreps(R)

function adjoint_fusion_ring(R::FusionRing)
    # Minimal implementation: build the fusion subring generated by adjoint irreps
    A = Set(adjoint_irreps(R))
    # TODO: close under tensor product using Operations.tensor_product
    throw(ErrorException("adjoint_fusion_ring: TODO close the subring; wrapper present."))
end

# --- Ring-theoretic series ---
is_nilpotent_fusion_ring(::FusionRing) = throw(NotImpl)
commutator(::FusionRing) = throw(NotImpl)
upper_central_series(::FusionRing) = throw(NotImpl)

# --- Gradings & automorphisms ---
universal_grading(R::FusionRing) = GroupTheory.universal_grading(R)
all_gradings(::FusionRing; kwargs...) = throw(NotImpl)
fusion_ring_automorphisms(R::FusionRing) = GroupTheory.fusion_ring_automorphisms(R)

# --- Identification ---
identify_fusion_ring(::FusionRing) = throw(NotImpl)

# --- Group rings ---
group_fusion_ring(::Any) = throw(NotImpl)  # use Creation.fusion_ring_from_group if/when available

# --- Self-duality counts (Anyonica aliases) ---
num_self_dual(R::FusionRing) = Properties.num_self_dual(R)
nsd(R::FusionRing) = num_self_dual(R)

num_non_self_dual(R::FusionRing) = Properties.num_non_self_dual(R)
nnsd(R::FusionRing) = num_non_self_dual(R)

# --- Stubs with explicit messages for known placeholders ---
son2_fusion_ring(::Int) = throw(NotImpl)
hi_fusion_ring(::Any)   = throw(NotImpl)

end # module
